step1
	p=0
	lb=-999999
	计算maxnpv
	对0-max_time看资源是否冲突
		冲突 step2
		不冲突 最优 结束

step2+step3  分支计算
												这里假设 DS1={2,4,6}的时候可以获得最优解 不需要化成{{2,4},6}
	p=p+1                                        eg. p=1
	计算DS 就是时间靠前的资源冲突活动集合        eg. DS={2,4,6}
	MS 就是DS的各种排列组合                      eg. MS={(2,4),(4,6),(2,6),(4,2),(6,2),(6,4)} 
													 每一组前面小于后面
	对MS中的所有DM                               eg DM=(2,4)
		f2=f4-d4 并且对所有的2活动中CT的前置进行前移
		计算ub （DC）  这里根据f计算的话其实不需要maxnpv迭代对吧
		对0-max_time看资源是否冲突
		冲突 分支 step2+step3      <-----
		不冲突  且ub>lb 更新lb          |
		不冲突 且ub<=lb 啥都不干        |
                                        |
										|
step2+3 里面有迭代部分-------------------
        可以直接返回上层,也就是step5



关于f的解决
	用一个数组存储所有子节点返回的lb和f
	最后取lb最大的那个lb和对应的f